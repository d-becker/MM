//
// auto-generated by mm.py
//
#include <iostream>
#include "MultidimArray.hpp"
#include "compressed_cell_centric/Arguments.hpp"
#include "compressed_cell_centric/Computation.hpp"

using namespace MM;
using namespace MM::compressed_cell_centric;


//user function
inline void anonymusAt2786(double rho, double Vf, double V, ReduceProxy<double> rho_ave) {
      rho_ave << rho*Vf/V;
      }

// host stub function
void mm_par_loop_anonymusAt2786(std::string name, Computation<2> &computation,
 IN<CellMatData<2>> arg0, IN<CellMatData<2>> arg1, IN<CellData<2>> arg2, REDUCE<CellData<2>> arg3) {
  const std::array<std::size_t, 2> &begin = computation.index_generator.get_begin();
  const std::array<std::size_t, 2> &end = computation.index_generator.get_end();

  CompressedDataStructure &structure = computation.data.structure;
  std::array<std::size_t,2> shape = computation.data.get_size();
  double * __restrict data0 = arg0.get_raw();
  double *__restrict data0_list = arg0.get_raw_list();
  double * __restrict data1 = arg1.get_raw();
  double *__restrict data1_list = arg1.get_raw_list();
  double * __restrict data2 = arg2.get_raw();
  #pragma omp parallel for collapse(1)
  for (std::size_t j = begin[1]; j < end[1]; j++) {
    #pragma omp simd
    for (std::size_t i = begin[0]; i < end[0]; i++) {
      if (structure.structure[i+j*shape[0]].nmats == 1) {
        std::size_t mat_index = structure.structure[i+j*shape[0]].imat;
        anonymusAt2786(
          data0[i+j*shape[0]],
          data1[i+j*shape[0]],
          data2[i+j*shape[0]],
          arg3.get(Coords<2>(i, j), computation.data, CellMatIndex(i+j*shape[0], mat_index), ValueIndex(ValueIndex::Type::SINGLE_MAT, i+j*shape[0])));
      } else {
        for (std::size_t structure_index = structure.structure[i+j*shape[0]].imat; 
            structure_index!=-1ul; structure_index = structure.mixed_storage[structure_index].nextfrac) {
          std::size_t mat_index = structure.mixed_storage[structure_index].material;
          anonymusAt2786(
            data0_list[structure_index],
            data1_list[structure_index],
            data2[i+j*shape[0]],
            arg3.get(Coords<2>(i, j), computation.data, CellMatIndex(i+j*shape[0], mat_index), ValueIndex(ValueIndex::Type::MULTIMAT, structure_index)));
        }
      }
    }
  }
}
